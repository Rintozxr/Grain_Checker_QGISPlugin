import math
from typing import Dict, List, Tuple, Any

import numpy as np
import processing

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsWkbTypes,
)


def _create_grid(point_layer: QgsVectorLayer, cell_size: float, output_name: str = None) -> QgsVectorLayer:
    """Create a rectangular grid covering the point layer extent."""
    extent = point_layer.extent()
    extent_str = f"{extent.xMinimum()},{extent.xMaximum()},{extent.yMinimum()},{extent.yMaximum()} [{point_layer.crs().authid()}]"

    result = processing.run(
        "native:creategrid",
        {
            "TYPE": 2,  # Rectangle (polygon)
            "EXTENT": extent_str,
            "HSPACING": cell_size,
            "VSPACING": cell_size,
            "HOVERLAY": 0,
            "VOVERLAY": 0,
            "CRS": point_layer.crs(),
            "OUTPUT": "memory:"
        }
    )
    grid_layer = result["OUTPUT"]
    if output_name:
        grid_layer.setName(output_name)
    return grid_layer



def _count_points_in_grid(grid_layer: QgsVectorLayer, point_layer: QgsVectorLayer, count_field_name: str) -> QgsVectorLayer:
    """
    Count points in each grid cell using QGIS-compatible algorithms.
    Returns a new polygon layer with a count field.
    """
    alg_candidates = [
        "native:countpointsinpolygon",
        "qgis:countpointsinpolygon",
    ]

    # Try building spatial index on point layer (performance optimization)
    try:
        processing.run("native:createspatialindex", {"INPUT": point_layer})
    except Exception:
        try:
            processing.run("qgis:createspatialindex", {"INPUT": point_layer})
        except Exception:
            pass

    params = {
        "POLYGONS": grid_layer,
        "POINTS": point_layer,
        "WEIGHT": None,          # plain count
        "CLASSFIELD": None,      # no grouped count
        "FIELD": count_field_name,
        "OUTPUT": "memory:"
    }

    last_err = None
    for alg_id in alg_candidates:
        try:
            result = processing.run(alg_id, params)
            return result["OUTPUT"]
        except Exception as e:
            last_err = e
            continue

    raise RuntimeError(
        f"No compatible 'count points in polygon' algorithm found. "
        f"Tried: {alg_candidates}. Last error: {last_err}"
    )


def _find_count_field_name(layer: QgsVectorLayer, prefix: str) -> str:
    """
    Find count field generated by joinbylocationsummary.
    Usually something like event_count / cov_count.
    """
    candidates = []
    for f in layer.fields():
        name = f.name()
        if "count" in name.lower():
            candidates.append(name)

    preferred = [n for n in candidates if n.lower().startswith(prefix.lower())]
    if preferred:
        return preferred[0]
    if candidates:
        return candidates[0]

    # Helpful debug info
    field_names = [f.name() for f in layer.fields()]
    raise RuntimeError(
        f"Could not find a count field (prefix={prefix}). Fields found: {field_names}"
    )


def _extract_density_pairs(
    joined_layer: QgsVectorLayer,
    event_count_field: str,
    cov_count_field: str,
    cell_size: float
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Extract per-cell event/covariate densities from a joined grid layer.
    density = count / cell_area
    """
    cell_area = float(cell_size) * float(cell_size)
    if cell_area <= 0:
        raise ValueError("Cell area must be positive.")

    event_vals = []
    cov_vals = []

    for feat in joined_layer.getFeatures():
        e = feat[event_count_field]
        c = feat[cov_count_field]

        e_count = 0.0 if e is None else float(e)
        c_count = 0.0 if c is None else float(c)

        event_vals.append(e_count / cell_area)
        cov_vals.append(c_count / cell_area)

    return np.array(event_vals, dtype=float), np.array(cov_vals, dtype=float)


def _pearson_r(x: np.ndarray, y: np.ndarray) -> float:
    """Pearson r with guards; exclude cells where both densities are zero."""
    if x.size != y.size:
        raise ValueError("x and y must have the same length.")
    if x.size < 2:
        return float("nan")

    # Keep cells where at least one variable is nonzero
    mask = ~((x == 0) & (y == 0))
    x2 = x[mask]
    y2 = y[mask]

    if x2.size < 2:
        return float("nan")
    if np.allclose(np.std(x2), 0) or np.allclose(np.std(y2), 0):
        return float("nan")

    return float(np.corrcoef(x2, y2)[0, 1])


def _summary_stats(arr: np.ndarray) -> Dict[str, Any]:
    """Basic descriptive stats."""
    if arr.size == 0:
        return {
            "n": 0,
            "mean": float("nan"),
            "std": float("nan"),
            "nonzero_ratio": float("nan"),
            "cv": float("nan"),
        }

    mean_val = float(np.mean(arr))
    std_val = float(np.std(arr))
    nonzero_ratio = float(np.count_nonzero(arr) / arr.size)
    cv_val = float("nan") if np.isclose(mean_val, 0) else float(std_val / mean_val)

    return {
        "n": int(arr.size),
        "mean": mean_val,
        "std": std_val,
        "nonzero_ratio": nonzero_ratio,
        "cv": cv_val,
    }


def run_bivariate_density_stress_test(
    event_layer: QgsVectorLayer,
    cov_layer: QgsVectorLayer,
    scales: List[float],
    add_layers_to_project: bool = True,
) -> Dict[str, Any]:
    """
    Grain-Checker v0.2-lite:
    Compare bivariate density relationship sensitivity across grid sizes.
    """
    if not isinstance(event_layer, QgsVectorLayer) or event_layer.geometryType() != QgsWkbTypes.PointGeometry:
        raise ValueError("event_layer must be a point vector layer.")
    if not isinstance(cov_layer, QgsVectorLayer) or cov_layer.geometryType() != QgsWkbTypes.PointGeometry:
        raise ValueError("cov_layer must be a point vector layer.")
    if not scales or len(scales) < 2:
        raise ValueError("Please provide at least 2 scales.")

    scales = [float(s) for s in scales]
    for s in scales:
        if s <= 0:
            raise ValueError("All scales must be positive.")

    per_scale = {}
    r_values = []

    for s in scales:
        # 1) Create grid
        grid = _create_grid(event_layer, s, output_name=f"grain_grid_{int(s)}m")

        # 2) Count event points in grid
        event_count_field = "event_count"
        grid_event = _count_points_in_grid(grid, event_layer, count_field_name=event_count_field)

        # 3) Count covariate points in the same (already event-counted) grid
        cov_count_field = "cov_count"
        grid_both = _count_points_in_grid(grid_event, cov_layer, count_field_name=cov_count_field)
        grid_both.setName(f"grain_{int(s)}m_event_cov")

        # 5) Extract densities
        event_density, cov_density = _extract_density_pairs(
            grid_both, event_count_field, cov_count_field, s
        )

        # 6) Correlation
        r = _pearson_r(event_density, cov_density)
        r_values.append(r)
        print(
            f"[GrainChecker] scale={s}, r={r}, event_nonzero={np.count_nonzero(event_density)}, cov_nonzero={np.count_nonzero(cov_density)}")

        # 7) Summary stats
        per_scale[s] = {
            "r": r,
            "event_stats": _summary_stats(event_density),
            "cov_stats": _summary_stats(cov_density),
            "layer": grid_both,
            "event_count_field": event_count_field,
            "cov_count_field": cov_count_field,
        }

        if add_layers_to_project:
            QgsProject.instance().addMapLayer(grid_both)

    finite_r = [v for v in r_values if v is not None and not (isinstance(v, float) and math.isnan(v))]
    if len(finite_r) < 2:
        r_range = float("nan")
        r_std = float("nan")
        label = "Insufficient"
    else:
        r_range = float(max(finite_r) - min(finite_r))
        r_std = float(np.std(finite_r))

        if r_range < 0.10:
            label = "Low"
        elif r_range < 0.25:
            label = "Moderate"
        else:
            label = "High"

    return {
        "per_scale": per_scale,
        "r_values": r_values,
        "r_range": r_range,
        "r_std": r_std,
        "sensitivity_label": label,
    }


def format_bivariate_result_message(result: Dict[str, Any]) -> str:
    """Format result text for QMessageBox."""
    lines = []
    lines.append("Grain-Checker v0.2-lite")
    lines.append("Bivariate Density Relationship Stress Test")
    lines.append("")

    for scale in sorted(result["per_scale"].keys()):
        item = result["per_scale"][scale]
        r = item["r"]
        r_txt = "nan" if (r is None or (isinstance(r, float) and math.isnan(r))) else f"{r:.3f}"

        ev = item["event_stats"]
        cv = item["cov_stats"]

        lines.append(f"Scale {int(scale)}m: r = {r_txt}")
        lines.append(
            f"  Event density: n={ev['n']}, nonzero={ev['nonzero_ratio']:.3f}, mean={ev['mean']:.6g}, cv={ev['cv']:.3f}"
        )
        lines.append(
            f"  Cov density:   n={cv['n']}, nonzero={cv['nonzero_ratio']:.3f}, mean={cv['mean']:.6g}, cv={cv['cv']:.3f}"
        )
        lines.append("")

    r_range = result["r_range"]
    r_std = result["r_std"]
    r_range_txt = "nan" if (isinstance(r_range, float) and math.isnan(r_range)) else f"{r_range:.3f}"
    r_std_txt = "nan" if (isinstance(r_std, float) and math.isnan(r_std)) else f"{r_std:.3f}"

    lines.append(f"Sensitivity (r range): {r_range_txt}")
    lines.append(f"Sensitivity (r std):   {r_std_txt}")
    lines.append(f"Label: {result['sensitivity_label']}")
    lines.append("")
    lines.append("Note: Pearson correlation is computed on grid-cell event/covariate densities at each scale.")

    return "\n".join(lines)